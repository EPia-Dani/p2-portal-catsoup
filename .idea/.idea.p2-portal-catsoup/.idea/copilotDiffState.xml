<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Portal/PortalGun.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Portal/PortalGun.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Portal {&#10;&#9;public class PortalGun : MonoBehaviour {&#10;&#9;&#9;[SerializeField] LayerMask shootMask = ~0;&#10;&#9;&#9;[SerializeField] float shootDistance = 1000f;&#10;&#9;&#9;[SerializeField] Camera shootCamera;&#10;&#9;&#9;[SerializeField] PortalManager portalManager;&#10;&#9;&#9;[SerializeField] Vector2 portalHalfSize = new(0.45f, 0.45f);&#10;&#9;&#9;[SerializeField] float wallOffset = 0.02f;&#10;&#9;&#9;[SerializeField] float clampSkin = 0.01f;&#10;&#10;&#9;&#9;static readonly Vector3 ViewportCenter = new(0.5f, 0.5f, 0f);&#10;&#9;&#9;const float SEP = 2.1f;       // push target in ellipse-space&#10;&#9;&#9;const float SEP_CHECK = 2.05f; // verify after clamp&#10;&#10;&#9;&#9;void Update() {&#10;&#9;&#9;&#9;var c = InputManager.PlayerInput;&#10;&#9;&#9;&#9;if (c.Player.ShootBlue.WasPerformedThisFrame())  Fire(0);&#10;&#9;&#9;&#9;if (c.Player.ShootOrange.WasPerformedThisFrame()) Fire(1);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;void Fire(int i) {&#10;&#9;&#9;&#9;if (!shootCamera || !portalManager) return;&#10;&#10;&#9;&#9;&#9;Ray ray = shootCamera.ViewportPointToRay(ViewportCenter);&#10;&#9;&#9;&#9;if (!Physics.Raycast(ray, out var hit, shootDistance, shootMask, QueryTriggerInteraction.Ignore)) return;&#10;&#9;&#9;&#9;var col = hit.collider; if (!col || !col.enabled) return;&#10;&#10;&#9;&#9;&#9;// Basis&#10;&#9;&#9;&#9;Vector3 n = hit.normal;&#10;&#9;&#9;&#9;Vector3 r = Vector3.ProjectOnPlane(shootCamera.transform.right, n);&#10;&#9;&#9;&#9;float rsq = r.sqrMagnitude;&#10;&#9;&#9;&#9;if (rsq &lt; 1e-4f) {&#10;&#9;&#9;&#9;&#9;r = Vector3.Cross(n, Vector3.up);&#10;&#9;&#9;&#9;&#9;if (r.sqrMagnitude &lt; 1e-6f) r = Vector3.Cross(n, Vector3.forward);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;r.Normalize();&#10;&#9;&#9;&#9;Vector3 u = Vector3.Cross(n, r); // orthonormal by construction&#10;&#10;&#9;&#9;&#9;// Plane center on the hit surface&#10;&#9;&#9;&#9;Bounds b = col.bounds;&#10;&#9;&#9;&#9;Vector3 bc = b.center;&#10;&#9;&#9;&#9;Vector3 center = bc + Vector3.Project(hit.point - bc, n);&#10;&#10;&#9;&#9;&#9;// Clamp extents along r/u using fused-abs dot&#10;&#9;&#9;&#9;Vector3 ext = b.extents;&#10;&#9;&#9;&#9;float ax = Mathf.Abs(r.x), ay = Mathf.Abs(r.y), az = Mathf.Abs(r.z);&#10;&#9;&#9;&#9;float ux = Mathf.Abs(u.x), uy = Mathf.Abs(u.y), uz = Mathf.Abs(u.z);&#10;&#9;&#9;&#9;float maxR = ext.x * ax + ext.y * ay + ext.z * az;&#10;&#9;&#9;&#9;float maxU = ext.x * ux + ext.y * uy + ext.z * uz;&#10;&#10;&#9;&#9;&#9;float clampR = maxR - portalHalfSize.x - clampSkin;&#10;&#9;&#9;&#9;float clampU = maxU - portalHalfSize.y - clampSkin;&#10;&#9;&#9;&#9;if (clampR &lt;= 0f || clampU &lt;= 0f) return;&#10;&#10;&#9;&#9;&#9;// Initial UV&#10;&#9;&#9;&#9;Vector3 d = hit.point - center;&#10;&#9;&#9;&#9;float uvR = Mathf.Clamp(Vector3.Dot(d, r), -clampR, clampR);&#10;&#9;&#9;&#9;float uvU = Mathf.Clamp(Vector3.Dot(d, u), -clampU, clampU);&#10;&#10;&#9;&#9;&#9;// Separation vs other portal on same face&#10;&#9;&#9;&#9;var otherOpt = portalManager.GetPortalState(1 - i);&#10;&#9;&#9;&#9;if (otherOpt.HasValue) {&#10;&#9;&#9;&#9;&#9;var op = otherOpt.Value;&#10;&#9;&#9;&#9;&#9;if (col == op.surface &amp;&amp; Vector3.Dot(n, op.normal) &gt; 0.99f) {&#10;&#9;&#9;&#9;&#9;&#9;Vector3 oc = op.worldCenter - center;&#10;&#9;&#9;&#9;&#9;&#9;float oR = Vector3.Dot(oc, r);&#10;&#9;&#9;&#9;&#9;&#9;float oU = Vector3.Dot(oc, u);&#10;&#10;&#9;&#9;&#9;&#9;&#9;float dR = uvR - oR;&#10;&#9;&#9;&#9;&#9;&#9;float dU = uvU - oU;&#10;&#10;&#9;&#9;&#9;&#9;&#9;// ellipse-space&#10;&#9;&#9;&#9;&#9;&#9;float eR = dR / portalHalfSize.x;&#10;&#9;&#9;&#9;&#9;&#9;float eU = dU / portalHalfSize.y;&#10;&#9;&#9;&#9;&#9;&#9;float mag = Mathf.Sqrt(eR * eR + eU * eU);&#10;&#10;&#9;&#9;&#9;&#9;&#9;if (mag &lt; SEP) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// push along ellipse direction&#10;&#9;&#9;&#9;&#9;&#9;&#9;float dirR, dirU;&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (mag &gt; 1e-3f) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float s = SEP / mag;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;dirR = eR * s;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;dirU = eU * s;&#10;&#9;&#9;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;dirR = SEP; dirU = 0f;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// back to RU&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvR = oR + dirR * portalHalfSize.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvU = oU + dirU * portalHalfSize.y;&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Clamp and verify&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvR = Mathf.Clamp(uvR, -clampR, clampR);&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvU = Mathf.Clamp(uvU, -clampU, clampU);&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;float fR = (uvR - oR) / portalHalfSize.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;float fU = (uvU - oU) / portalHalfSize.y;&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (Mathf.Sqrt(fR * fR + fU * fU) &lt; SEP_CHECK) return;&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;Vector3 worldPos = center + r * uvR + u * uvU;&#10;&#9;&#9;&#9;portalManager.PlacePortal(i, worldPos, n, r, u, col, wallOffset);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Portal {&#10;&#9;public class PortalGun : MonoBehaviour {&#10;&#9;&#9;[SerializeField] LayerMask shootMask = ~0;&#10;&#9;&#9;[SerializeField] float shootDistance = 1000f;&#10;&#9;&#9;[SerializeField] Camera shootCamera;&#10;&#9;&#9;[SerializeField] PortalManager portalManager;&#10;&#9;&#9;[SerializeField] Vector2 portalHalfSize = new(0.45f, 0.45f);&#10;&#9;&#9;[SerializeField] float wallOffset = 0.02f;&#10;&#9;&#9;[SerializeField] float clampSkin = 0.01f;&#10;&#10;&#9;&#9;static readonly Vector3 ViewportCenter = new(0.5f, 0.5f, 0f);&#10;&#9;&#9;const float Sep = 2.1f;       // push target in ellipse-space&#10;&#9;&#9;const float SepCheck = 2.05f; // verify after clamp&#10;&#10;&#9;&#9;void Update() {&#10;&#9;&#9;&#9;var c = InputManager.PlayerInput;&#10;&#9;&#9;&#9;if (c.Player.ShootBlue.WasPerformedThisFrame())  Fire(0);&#10;&#9;&#9;&#9;if (c.Player.ShootOrange.WasPerformedThisFrame()) Fire(1);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;void Fire(int i) {&#10;&#9;&#9;&#9;if (!shootCamera || !portalManager) return;&#10;&#10;&#9;&#9;&#9;Ray ray = shootCamera.ViewportPointToRay(ViewportCenter);&#10;&#9;&#9;&#9;if (!Physics.Raycast(ray, out var hit, shootDistance, shootMask, QueryTriggerInteraction.Ignore)) return;&#10;&#9;&#9;&#9;var col = hit.collider; if (!col || !col.enabled) return;&#10;&#10;&#9;&#9;&#9;// Basis&#10;&#9;&#9;&#9;Vector3 n = hit.normal;&#10;&#9;&#9;&#9;// Default: try to align portal roll with the camera right projected onto the hit plane&#10;&#9;&#9;&#9;Vector3 r = Vector3.ProjectOnPlane(shootCamera.transform.right, n);&#10;&#9;&#9;&#9;float rsq = r.sqrMagnitude;&#10;&#9;&#9;&#9;if (rsq &lt; 1e-4f) {&#10;&#9;&#9;&#9;&#9;// camera right is nearly parallel to the normal -&gt; fall back to cross with world axes&#10;&#9;&#9;&#9;&#9;r = Vector3.Cross(n, Vector3.up);&#10;&#9;&#9;&#9;&#9;if (r.sqrMagnitude &lt; 1e-6f) r = Vector3.Cross(n, Vector3.forward);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;r.Normalize();&#10;&#9;&#9;&#9;// Compute up from camera-projected basis by default&#10;&#9;&#9;&#9;Vector3 u = Vector3.Cross(n, r); // orthonormal by construction&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;// If the surface is inclined (i.e. world-up has a non-zero tangent on the surface),&#10;&#9;&#9;&#9;// prefer using the surface's &quot;y axis&quot; — the projection of world-up onto the plane —&#10;&#9;&#9;&#9;// so the portal appears upright relative to world Y while still conforming to the surface.&#10;&#9;&#9;&#9;Vector3 upProjected = Vector3.ProjectOnPlane(Vector3.up, n);&#10;&#9;&#9;&#9;if (upProjected.sqrMagnitude &gt; 1e-4f) {&#10;&#9;&#9;&#9;&#9;u = upProjected.normalized;&#10;&#9;&#9;&#9;&#9;// recompute right to maintain orthonormal basis&#10;&#9;&#9;&#9;&#9;r = Vector3.Cross(n, u);&#10;&#9;&#9;&#9;&#9;if (r.sqrMagnitude &lt; 1e-6f) {&#10;&#9;&#9;&#9;&#9;&#9;// fallback to camera-based right if degenerate&#10;&#9;&#9;&#9;&#9;&#9;r = Vector3.ProjectOnPlane(shootCamera.transform.right, n);&#10;&#9;&#9;&#9;&#9;&#9;if (r.sqrMagnitude &lt; 1e-6f) r = Vector3.Cross(n, Vector3.up);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;r.Normalize();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// Plane center on the hit surface&#10;&#9;&#9;&#9;Bounds b = col.bounds;&#10;&#9;&#9;&#9;Vector3 bc = b.center;&#10;&#9;&#9;&#9;Vector3 center = bc + Vector3.Project(hit.point - bc, n);&#10;&#10;&#9;&#9;&#9;// Clamp extents along r/u using fused-abs dot&#10;&#9;&#9;&#9;Vector3 ext = b.extents;&#10;&#9;&#9;&#9;float ax = Mathf.Abs(r.x), ay = Mathf.Abs(r.y), az = Mathf.Abs(r.z);&#10;&#9;&#9;&#9;float ux = Mathf.Abs(u.x), uy = Mathf.Abs(u.y), uz = Mathf.Abs(u.z);&#10;&#9;&#9;&#9;float maxR = ext.x * ax + ext.y * ay + ext.z * az;&#10;&#9;&#9;&#9;float maxU = ext.x * ux + ext.y * uy + ext.z * uz;&#10;&#10;&#9;&#9;&#9;float clampR = maxR - portalHalfSize.x - clampSkin;&#10;&#9;&#9;&#9;float clampU = maxU - portalHalfSize.y - clampSkin;&#10;&#9;&#9;&#9;if (clampR &lt;= 0f || clampU &lt;= 0f) return;&#10;&#10;&#9;&#9;&#9;// Initial UV&#10;&#9;&#9;&#9;Vector3 d = hit.point - center;&#10;&#9;&#9;&#9;float uvR = Mathf.Clamp(Vector3.Dot(d, r), -clampR, clampR);&#10;&#9;&#9;&#9;float uvU = Mathf.Clamp(Vector3.Dot(d, u), -clampU, clampU);&#10;&#10;&#9;&#9;&#9;// Separation vs other portal on same face&#10;&#9;&#9;&#9;var otherOpt = portalManager.GetPortalState(1 - i);&#10;&#9;&#9;&#9;if (otherOpt.HasValue) {&#10;&#9;&#9;&#9;&#9;var op = otherOpt.Value;&#10;&#9;&#9;&#9;&#9;if (col == op.surface &amp;&amp; Vector3.Dot(n, op.normal) &gt; 0.99f) {&#10;&#9;&#9;&#9;&#9;&#9;Vector3 oc = op.worldCenter - center;&#10;&#9;&#9;&#9;&#9;&#9;float oR = Vector3.Dot(oc, r);&#10;&#9;&#9;&#9;&#9;&#9;float oU = Vector3.Dot(oc, u);&#10;&#10;&#9;&#9;&#9;&#9;&#9;float dR = uvR - oR;&#10;&#9;&#9;&#9;&#9;&#9;float dU = uvU - oU;&#10;&#10;&#9;&#9;&#9;&#9;&#9;// ellipse-space&#10;&#9;&#9;&#9;&#9;&#9;float eR = dR / portalHalfSize.x;&#10;&#9;&#9;&#9;&#9;&#9;float eU = dU / portalHalfSize.y;&#10;&#9;&#9;&#9;&#9;&#9;float mag = Mathf.Sqrt(eR * eR + eU * eU);&#10;&#10;&#9;&#9;&#9;&#9;&#9;if (mag &lt; Sep) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// push along ellipse direction&#10;&#9;&#9;&#9;&#9;&#9;&#9;float dirR, dirU;&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (mag &gt; 1e-3f) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;float s = Sep / mag;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;dirR = eR * s;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;dirU = eU * s;&#10;&#9;&#9;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;dirR = Sep; dirU = 0f;&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// back to RU&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvR = oR + dirR * portalHalfSize.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvU = oU + dirU * portalHalfSize.y;&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// Clamp and verify&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvR = Mathf.Clamp(uvR, -clampR, clampR);&#10;&#9;&#9;&#9;&#9;&#9;&#9;uvU = Mathf.Clamp(uvU, -clampU, clampU);&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;float fR = (uvR - oR) / portalHalfSize.x;&#10;&#9;&#9;&#9;&#9;&#9;&#9;float fU = (uvU - oU) / portalHalfSize.y;&#10;&#9;&#9;&#9;&#9;&#9;&#9;if (Mathf.Sqrt(fR * fR + fU * fU) &lt; SepCheck) return;&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;Vector3 worldPos = center + r * uvR + u * uvU;&#10;&#9;&#9;&#9;portalManager.PlacePortal(i, worldPos, n, r, u, col, wallOffset);&#10;&#9;&#9;}&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>