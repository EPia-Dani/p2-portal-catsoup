<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Portal/PortalAnimator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Portal/PortalAnimator.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;namespace Portal {&#10;&#9;public class PortalAnimator : MonoBehaviour&#10;&#9;{&#10;&#9;&#9;private float portalOpenDuration = 1f;&#10;&#9;&#9;private AnimationCurve portalOpenCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);&#10;&#9;&#9;private float portalAppearDuration = 0.3f;&#10;&#9;&#9;private float portalTargetRadius = 0.4f;&#10;&#9;&#9;private AnimationCurve portalAppearCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);&#10;&#9;&#9;private float openThreshold = 0.8f;&#10;&#10;&#9;&#9;private static readonly int CircleRadiusId = Shader.PropertyToID(&quot;_CircleRadius&quot;);&#10;&#9;&#9;private static readonly int PortalOpenId = Shader.PropertyToID(&quot;_PortalOpen&quot;);&#10;&#10;&#9;&#9;private MeshRenderer _portalMeshRenderer;&#10;&#9;&#9;private MaterialPropertyBlock _propertyBlock;&#10;&#9;&#9;private Coroutine _openingCoroutine;&#10;&#9;&#9;private Coroutine _appearCoroutine;&#10;&#9;&#9;private float _portalOpenProgress;&#10;&#9;&#9;private float _currentCircleRadius;&#10;&#10;&#9;&#9;public bool IsOpening =&gt; _openingCoroutine != null;&#10;&#9;&#9;public bool IsFullyOpen =&gt; _portalOpenProgress &gt;= openThreshold;&#10;&#10;&#9;&#9;public void Configure(MeshRenderer meshRenderer)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_portalMeshRenderer = meshRenderer;&#10;&#9;&#9;&#9;if (_propertyBlock == null) _propertyBlock = new MaterialPropertyBlock();&#10;&#9;&#9;&#9;_currentCircleRadius = portalTargetRadius;&#10;&#9;&#9;&#9;ApplyToMaterial();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Sets all animation settings at once&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;public void SetAnimationSettings(&#10;&#9;&#9;&#9;float openDuration,&#10;&#9;&#9;&#9;AnimationCurve openCurve,&#10;&#9;&#9;&#9;float appearDuration,&#10;&#9;&#9;&#9;float targetRadius,&#10;&#9;&#9;&#9;AnimationCurve appearCurve,&#10;&#9;&#9;&#9;float threshold)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;portalOpenDuration = Mathf.Max(0.1f, openDuration);&#10;&#9;&#9;&#9;portalOpenCurve = openCurve != null ? openCurve : AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);&#10;&#9;&#9;&#9;portalAppearDuration = Mathf.Max(0.1f, appearDuration);&#10;&#9;&#9;&#9;portalTargetRadius = Mathf.Max(0.1f, targetRadius);&#10;&#9;&#9;&#9;portalAppearCurve = appearCurve != null ? appearCurve : AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);&#10;&#9;&#9;&#9;openThreshold = Mathf.Clamp01(threshold);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void PlayAppear()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (!_portalMeshRenderer) return;&#10;&#9;&#9;&#9;if (_appearCoroutine != null) StopCoroutine(_appearCoroutine);&#10;&#9;&#9;&#9;_appearCoroutine = StartCoroutine(AppearRoutine());&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void StartOpening()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (!_portalMeshRenderer) return;&#10;&#9;&#9;&#9;if (_openingCoroutine != null) StopCoroutine(_openingCoroutine);&#10;&#9;&#9;&#9;_openingCoroutine = StartCoroutine(OpeningRoutine());&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void HideImmediate()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (_openingCoroutine != null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;StopCoroutine(_openingCoroutine);&#10;&#9;&#9;&#9;&#9;_openingCoroutine = null;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if (_appearCoroutine != null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;StopCoroutine(_appearCoroutine);&#10;&#9;&#9;&#9;&#9;_appearCoroutine = null;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;_portalOpenProgress = 0f;&#10;&#9;&#9;&#9;SetCircleRadius(0f);&#10;&#9;&#9;&#9;ApplyToMaterial();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;private IEnumerator AppearRoutine()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;SetCircleRadius(0f);&#10;&#10;&#9;&#9;&#9;float elapsed = 0f;&#10;&#9;&#9;&#9;while (elapsed &lt; portalAppearDuration)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;elapsed += Time.deltaTime;&#10;&#9;&#9;&#9;&#9;float t = Mathf.Clamp01(elapsed / portalAppearDuration);&#10;&#9;&#9;&#9;&#9;SetCircleRadius(portalTargetRadius * portalAppearCurve.Evaluate(t));&#10;&#9;&#9;&#9;&#9;yield return null;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;SetCircleRadius(portalTargetRadius);&#10;&#9;&#9;&#9;_appearCoroutine = null;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;private IEnumerator OpeningRoutine()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_portalOpenProgress = 0f;&#10;&#9;&#9;&#9;float elapsed = 0f;&#10;&#10;&#9;&#9;&#9;while (elapsed &lt; portalOpenDuration)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;elapsed += Time.deltaTime;&#10;&#9;&#9;&#9;&#9;float t = Mathf.Clamp01(elapsed / portalOpenDuration);&#10;&#9;&#9;&#9;&#9;_portalOpenProgress = Mathf.Clamp01(portalOpenCurve.Evaluate(t) * openThreshold);&#10;&#9;&#9;&#9;&#9;ApplyToMaterial();&#10;&#9;&#9;&#9;&#9;yield return null;&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;_portalOpenProgress = openThreshold;&#10;&#9;&#9;&#9;ApplyToMaterial();&#10;&#9;&#9;&#9;_openingCoroutine = null;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;private void SetCircleRadius(float radius)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_currentCircleRadius = radius;&#10;&#9;&#9;&#9;ApplyToMaterial();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;private void ApplyToMaterial()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (!_portalMeshRenderer) return;&#10;&#9;&#9;&#9;_propertyBlock.SetFloat(CircleRadiusId, _currentCircleRadius);&#10;&#9;&#9;&#9;_propertyBlock.SetFloat(PortalOpenId, _portalOpenProgress);&#10;&#9;&#9;&#9;_portalMeshRenderer.SetPropertyBlock(_propertyBlock);&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Portal {&#10;&#9;[System.Obsolete(&quot;PortalAnimator is deprecated — use Portal component instead.&quot;)]&#10;&#9;public class PortalAnimator : MonoBehaviour&#10;&#9;{&#10;&#9;&#9;private void Awake()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Debug.LogWarning(&quot;PortalAnimator is deprecated — the Portal component now contains animation logic. Remove PortalAnimator from GameObjects.&quot;, this);&#10;&#9;&#9;&#9;this.enabled = false;&#10;&#9;&#9;}&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Portal/PortalRenderView.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Portal/PortalRenderView.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.Rendering;&#10;using UnityEngine.Rendering.Universal;&#10;&#10;namespace Portal {&#10;&#9;public class PortalRenderView : MonoBehaviour&#10;&#9;{&#10;&#9;&#9;[SerializeField] private Camera portalCamera;&#10;&#9;&#9;[SerializeField] private MeshRenderer surfaceRenderer;&#10;&#9;&#9;private int textureWidth = 1024;&#10;&#9;&#9;private int textureHeight = 1024;&#10;&#9;&#9;private float clipPlaneOffset = 0.01f;&#10;&#10;&#9;&#9;private RenderTexture _renderTexture;&#10;        // Removed unused CommandBuffer to avoid invalid SetRenderTarget calls in URP&#10;&#9;&#9;private bool _isVisible = true;&#10;&#9;&#9;&#10;&#9;&#9;// Cached objects to avoid per-frame allocations&#10;&#9;&#9;private Vector4 _cachedClipPlane;&#10;&#9;&#9;private Vector3 _cachedPosition;&#10;&#9;&#9;private Vector3 _cachedForward;&#10;&#9;&#9;private Vector3 _cachedUp;&#10;&#9;&#9;private Vector3 _cachedPlanePoint;&#10;&#9;&#9;private Vector3 _cachedCameraPlaneNormal;&#10;&#9;&#9;private Vector3 _cachedCameraPlanePoint;&#10;&#9;&#9;&#10;&#9;&#9;// Cached GameObject reference to avoid property access&#10;&#9;&#9;private GameObject _cachedCameraGameObject;&#10;&#10;&#9;&#9;public MeshRenderer SurfaceRenderer =&gt; surfaceRenderer;&#10;&#9;&#9;public bool IsVisible =&gt; _isVisible;&#10;&#10;&#9;&#9;public void Initialize()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (!portalCamera) portalCamera = GetComponentInChildren&lt;Camera&gt;(true);&#10;&#9;&#9;&#9;if (!surfaceRenderer) surfaceRenderer = GetComponentInChildren&lt;MeshRenderer&gt;(true);&#10;&#10;&#9;&#9;&#9;if (!portalCamera)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;Debug.LogError(&quot;PortalRenderView: Portal camera not found! Add a Camera component as a child or assign in inspector.&quot;, this);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if (!surfaceRenderer)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;Debug.LogError(&quot;PortalRenderView: Surface renderer not found! Add a MeshRenderer component as a child or assign in inspector.&quot;, this);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// Cache camera GameObject reference&#10;&#9;&#9;&#9;if (portalCamera != null) _cachedCameraGameObject = portalCamera.gameObject;&#10;&#10;&#9;&#9;&#9;ConfigureCamera();&#10;&#9;&#9;&#9;EnsureRenderTexture();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Sets the texture size for the portal render texture&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;public void SetTextureSize(int width, int height)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;textureWidth = Mathf.Max(64, width);&#10;&#9;&#9;&#9;textureHeight = Mathf.Max(64, height);&#10;&#9;&#9;&#9;// Force render texture recreation with new settings&#10;&#9;&#9;&#9;if (_renderTexture != null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;_renderTexture.Release();&#10;&#9;&#9;&#9;&#9;Destroy(_renderTexture);&#10;&#9;&#9;&#9;&#9;_renderTexture = null;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;EnsureRenderTexture();&#10;&#9;&#9;}&#10;&#10;&#9;&#9;/// &lt;summary&gt;&#10;&#9;&#9;/// Sets the clip plane offset for portal rendering&#10;&#9;&#9;/// &lt;/summary&gt;&#10;&#9;&#9;public void SetClipPlaneOffset(float offset)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;clipPlaneOffset = Mathf.Max(0.001f, offset);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void ConfigureCamera()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (!portalCamera) return;&#10;&#10;&#9;&#9;&#9;portalCamera.enabled = false;&#10;&#9;&#9;&#9;portalCamera.forceIntoRenderTexture = true;&#10;&#9;&#9;&#9;portalCamera.allowHDR = false;&#10;&#9;&#9;&#9;portalCamera.useOcclusionCulling = false;&#10;&#9;&#9;&#9;portalCamera.clearFlags = CameraClearFlags.SolidColor;&#10;&#9;&#9;&#9;portalCamera.backgroundColor = Color.clear;&#10;&#10;&#9;&#9;&#9;var extra = portalCamera.GetUniversalAdditionalCameraData();&#10;&#9;&#9;&#9;if (extra != null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;extra.renderPostProcessing = false;&#10;&#9;&#9;&#9;&#9;extra.antialiasing = AntialiasingMode.None;&#10;&#9;&#9;&#9;&#9;extra.requiresColorOption = CameraOverrideOption.On;&#10;&#9;&#9;&#9;&#9;extra.requiresDepthOption = CameraOverrideOption.On;&#10;&#9;&#9;&#9;&#9;extra.SetRenderer(0);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void EnsureRenderTexture()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (portalCamera == null) return;&#10;&#10;&#9;&#9;&#9;if (_renderTexture == null || _renderTexture.width != textureWidth || _renderTexture.height != textureHeight)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;if (_renderTexture != null)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;_renderTexture.Release();&#10;&#9;&#9;&#9;&#9;&#9;Destroy(_renderTexture);&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;_renderTexture = new RenderTexture(textureWidth, textureHeight, 24, RenderTextureFormat.ARGB32)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;wrapMode = TextureWrapMode.Clamp,&#10;&#9;&#9;&#9;&#9;&#9;filterMode = FilterMode.Bilinear&#10;&#9;&#9;&#9;&#9;};&#10;&#9;&#9;&#9;&#9;_renderTexture.Create();&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;portalCamera.targetTexture = _renderTexture;&#10;&#9;&#9;&#9;if (surfaceRenderer)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;surfaceRenderer.sharedMaterial.mainTexture = _renderTexture;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void ClearTexture()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (_renderTexture == null) return;&#10;&#9;&#9;&#9;var prev = RenderTexture.active;&#10;&#9;&#9;&#9;RenderTexture.active = _renderTexture;&#10;&#9;&#9;&#9;GL.Clear(true, true, Color.clear);&#10;&#9;&#9;&#9;RenderTexture.active = prev;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void SetVisible(bool visible)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_isVisible = visible;&#10;&#9;&#9;&#9;if (_cachedCameraGameObject != null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;if (_cachedCameraGameObject.activeSelf != visible)&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;_cachedCameraGameObject.SetActive(visible);&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if (surfaceRenderer != null)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;surfaceRenderer.enabled = visible;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;public void RenderLevel(&#10;&#9;&#9;&#9;ScriptableRenderContext context,&#10;&#9;&#9;&#9;Camera mainCamera,&#10;&#9;&#9;&#9;Matrix4x4 worldMatrix,&#10;&#9;&#9;&#9;Vector3 destinationForward,&#10;&#9;&#9;&#9;Vector3 destinationPosition)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;if (portalCamera == null || mainCamera == null || !_isVisible) return;&#10;&#10;&#9;&#9;&#9;EnsureRenderTexture();&#10;&#10;&#9;&#9;&#9;// Use cached Vector3 fields to avoid allocations&#10;&#9;&#9;&#9;_cachedPosition = worldMatrix.MultiplyPoint(Vector3.zero);&#10;&#9;&#9;&#9;_cachedForward = worldMatrix.MultiplyVector(Vector3.forward);&#10;&#9;&#9;&#9;_cachedUp = worldMatrix.MultiplyVector(Vector3.up);&#10;&#10;&#9;&#9;&#9;portalCamera.transform.SetPositionAndRotation(_cachedPosition, Quaternion.LookRotation(_cachedForward, _cachedUp));&#10;&#10;&#9;&#9;&#9;// Calculate plane point using cached vector&#10;&#9;&#9;&#9;float offset = clipPlaneOffset;&#10;&#9;&#9;&#9;_cachedPlanePoint.x = destinationPosition.x + destinationForward.x * offset;&#10;&#9;&#9;&#9;_cachedPlanePoint.y = destinationPosition.y + destinationForward.y * offset;&#10;&#9;&#9;&#9;_cachedPlanePoint.z = destinationPosition.z + destinationForward.z * offset;&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;Matrix4x4 worldToCamera = portalCamera.worldToCameraMatrix;&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;// Calculate normal using cached vector (avoid temporary allocation from normalized)&#10;&#9;&#9;&#9;_cachedCameraPlaneNormal = worldToCamera.MultiplyVector(destinationForward);&#10;&#9;&#9;&#9;float normalMag = Mathf.Sqrt(_cachedCameraPlaneNormal.x * _cachedCameraPlaneNormal.x + &#10;&#9;&#9;&#9;                             _cachedCameraPlaneNormal.y * _cachedCameraPlaneNormal.y + &#10;&#9;&#9;&#9;                             _cachedCameraPlaneNormal.z * _cachedCameraPlaneNormal.z);&#10;&#9;&#9;&#9;if (normalMag &gt; 1e-6f)&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;float invMag = -1f / normalMag;&#10;&#9;&#9;&#9;&#9;_cachedCameraPlaneNormal.x *= invMag;&#10;&#9;&#9;&#9;&#9;_cachedCameraPlaneNormal.y *= invMag;&#10;&#9;&#9;&#9;&#9;_cachedCameraPlaneNormal.z *= invMag;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;_cachedCameraPlanePoint = worldToCamera.MultiplyPoint(_cachedPlanePoint);&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;// Reuse cached Vector4 instead of allocating new one&#10;&#9;&#9;&#9;_cachedClipPlane.x = _cachedCameraPlaneNormal.x;&#10;&#9;&#9;&#9;_cachedClipPlane.y = _cachedCameraPlaneNormal.y;&#10;&#9;&#9;&#9;_cachedClipPlane.z = _cachedCameraPlaneNormal.z;&#10;&#9;&#9;&#9;_cachedClipPlane.w = -(_cachedCameraPlanePoint.x * _cachedCameraPlaneNormal.x + &#10;&#9;&#9;&#9;                        _cachedCameraPlanePoint.y * _cachedCameraPlaneNormal.y + &#10;&#9;&#9;&#9;                        _cachedCameraPlanePoint.z * _cachedCameraPlaneNormal.z);&#10;&#10;&#9;&#9;&#9;portalCamera.projectionMatrix = mainCamera.CalculateObliqueMatrix(_cachedClipPlane);&#10;&#10;&#9;&#9;&#9;RenderPipeline.SubmitRenderRequest(portalCamera, new UniversalRenderPipeline.SingleCameraRequest());&#10;&#10;&#9;&#9;&#9;portalCamera.ResetProjectionMatrix();&#10;&#9;&#9;}&#10;&#10;        // Intentionally no CommandBuffer usage here; URP handles targets internally during SubmitRenderRequest&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Portal {&#10;&#9;[System.Obsolete(&quot;PortalRenderView is deprecated — use Portal component instead.&quot;)]&#10;&#9;public class PortalRenderView : MonoBehaviour&#10;&#9;{&#10;&#9;&#9;private void Awake()&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Debug.LogWarning(&quot;PortalRenderView is deprecated — the Portal component now contains render/view logic. Remove PortalRenderView from GameObjects.&quot;, this);&#10;&#9;&#9;&#9;// Prevent any legacy behavior if this component is still present&#10;&#9;&#9;&#9;this.enabled = false;&#10;&#9;&#9;}&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>